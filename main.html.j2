<!DOCTYPE html>
{# This file is licenced under the GNU AGPLv3 or later
   (c) 2023 David Koňařík #}
<html lang=en>
<head>
    <meta charset=utf-8>
    <title>XML schema: {{ main_xml_path.name }}</title>
    <script>
        /**
         * Builds a hierarchical path by traversing up the DOM tree.
         * Collects data-name attributes from ancestors until reaching an element
         * with data-belowroot (direct schema child). Skips TEMPLATE elements.
         * @param {HTMLElement} el - Starting element
         * @returns {string[]} Path segments from innermost to outermost (e.g., ["ChildElem", "ParentType"])
         */
        function domElementPath(el) {
            const path = [];
            while(el.parentElement) {
                if(el.tagName.toUpperCase() != "TEMPLATE" && el.dataset.name) {
                    path.push(el.dataset.name);
                }
                if(el.dataset.belowroot) {
                    break;
                }
                el = el.parentElement;
            }
            return path;
        }

        /**
         * Finds the best matching template for a reference path.
         * Tries progressively shorter paths (full path, then dropping segments from end)
         * to find the most specific template. Falls back to name-only match if no
         * path-based match is found.
         * @param {string|null} type - Template type filter (e.g., "element-contents", "type-contents")
         * @param {string[]} path - Path segments to match against template data-path attributes
         * @returns {HTMLTemplateElement|null} Matching template element or null
         */
        function closestTemplateForPath(type, path) {
            for(let i = path.length; i > 0; i--) {
                const cutPath = path.slice(0, i);
                const cutPathStr = cutPath.join("/");
                const templateEl = document.querySelector(
                    (type ? `template[data-type="${type}"]` : "")
                    + `[data-path="${cutPathStr}"]`);
                if(templateEl) return templateEl;
            }

            // Path based match failed, try any name
            return document.querySelector(
                (type ? `template[data-type="${type}"]` : "")
                + `[data-name="${path[0]}"]`);
        }

        /**
         * Removes empty attribute container boxes after template insertion.
         * Cleans up boxes (.complex-type-attrs, .extension-attrs, .restriction-attrs,
         * .attribute-group) that contain no .attribute children.
         * @param {HTMLElement} rootEl - Root element to search within
         */
        function removeEmptyBoxes(rootEl) {
            rootEl.querySelectorAll(".complex-type-attrs, .extension-attrs,"
                + ".restriction-attrs, .attribute-group")
                .forEach(boxEl => {
                    const isEmpty = boxEl.querySelectorAll(".attribute")
                                        .length == 0;
                    if(isEmpty) {
                        boxEl.parentElement.removeChild(boxEl);
                    }
                });
        }

        /**
         * Removes all child elements from a parent element.
         * @param {HTMLElement} el - Parent element to clear
         */
        function removeChildren(el) {
            [...el.children].forEach(c => el.removeChild(c));
        }

        /**
         * Custom element that resolves XSD references by finding and cloning
         * matching template content. Core mechanism for lazy-loading schema documentation.
         * @customElement xbe-ref
         * @attr {string} ref - Name of the referenced element/type/group
         * @attr {string} [type] - Template type filter (e.g., "element-contents", "type-contents")
         */
        class ReferenceElement extends HTMLElement {
            /** @inheritdoc */
            connectedCallback() {
                if(!this.isConnected) return; // MDN says I should have this

                const thisPath = domElementPath(this);
                const path = [this.getAttribute("ref"), ...thisPath];
                const type = this.getAttribute("type");
                const template = closestTemplateForPath(type, path);
                if(!template) {
                    console.error(`No template for ${path}! (type ${type})`);
                    return;
                }
                const contentEl = template.content.cloneNode(true);
                /*contentEl.prepend(
                    document.createComment(
                        `Loaded ${template.dataset.path} for path ${path}`));*/
                this.appendChild(contentEl);
                removeEmptyBoxes(this);
            }
        }
        customElements.define("xbe-ref", ReferenceElement);

        /**
         * Custom element that creates an expandable/collapsible element view.
         * Displays the element header with a toggle to show/hide contents.
         * Also recursively displays elements from substitution groups.
         * @customElement xbe-collapsible-element-ref
         * @attr {string} element - Name of the XSD element to display
         */
        class CollapsipleElementRefElement extends HTMLElement {
            /** @inheritdoc */
            connectedCallback() {
                if(!this.isConnected) return;

                this.afterHeadContent = this.querySelector("[slot=after-head]");
                const element = this.getAttribute("element");


                removeChildren(this);
                this.addElement(this, element);

                const addFromSubstGroup = (parent, substGroup) => {
                    const substituents = document.querySelectorAll(
                        `[data-type=element-head][data-substgroup="${substGroup}"]`);
                    if(substituents.length > 0) {
                        const box = document.createElement("div");
                        box.classList.add("substitution-group");
                        const origin = document.createElement("div");
                        origin.classList.add("origin");
                        origin.innerText = `Substitution group ${element}`;
                        box.appendChild(origin);
                        substituents.forEach(subst => {
                            this.addElement(box, subst.dataset.path);
                        });
                        substituents.forEach(subst => {
                            addFromSubstGroup(box, subst.dataset.name);
                        });
                        parent.appendChild(box);
                    }
                }
                addFromSubstGroup(this, element);
            }

            /**
             * Creates a collapsible details element for an XSD element.
             * Clones the collapsible-element-ref-template, substitutes the element
             * name into placeholders, and appends to the container.
             * @param {HTMLElement} base - Container to append the element to
             * @param {string} element - Name of the XSD element
             */
            addElement(base, element) {
                const template = document.getElementById(
                    "collapsible-element-ref-template");
                const baseContentEl = template.content.cloneNode(true);
                const detailsEl = baseContentEl.querySelector("details");
                detailsEl.dataset.element = element;
                baseContentEl
                    .querySelectorAll(".simple, .element-end")
                    .forEach(el =>
                        el.innerText = el.innerText.replaceAll("ELEMENT", element));
                baseContentEl.querySelector("xbe-ref").setAttribute("ref", element);
                const afterHeadSlot =
                    baseContentEl.querySelector("slot[name=after-head]");
                if(this.afterHeadContent)
                    [...this.afterHeadContent.children].forEach(
                        c => afterHeadSlot.appendChild(c));

                base.appendChild(baseContentEl);
            }
        }
        customElements.define("xbe-collapsible-element-ref",
            CollapsipleElementRefElement);

        /**
         * Handles toggle events on collapsible element details.
         * Lazy-loads element contents when opened (creates xbe-ref),
         * removes content when closed to save memory.
         * @param {HTMLDetailsElement} detailEl - The details element being toggled
         */
        function onCollapsibleElementRefToggle(detailEl) {
            const elemName = detailEl.dataset.element;
            const contentsEl = detailEl.querySelector(":scope > .element-contents");
            if(detailEl.open) {
                if(!contentsEl.querySelector(":scope > xbe-ref")) {
                    const refEl = document.createElement("xbe-ref");
                    refEl.setAttribute("type", "element-contents");
                    refEl.setAttribute("ref", elemName);
                    contentsEl.appendChild(refEl);
                }
            } else {
                const refEl = contentsEl.querySelector(":scope > xbe-ref");
                if(refEl) refEl.parentElement.removeChild(refEl);
            }
        }

        /**
         * Form submit handler for element picker.
         * Navigates to the selected element by updating URL hash.
         * @returns {false} Prevents default form submission
         */
        function onElementFormSubmit() {
            const element = document.getElementById("root-element-name").value;
            window.location.hash = `#element-${element}`;
            return false;
        }

        /**
         * Auto-navigates when user selects an element from the datalist dropdown.
         * Checks if input value exactly matches a datalist option; if so, navigates.
         */
        function onElementInputChange() {
            const input = document.getElementById("root-element-name");
            const datalist = document.getElementById("element-list");
            const options = [...datalist.options].map(o => o.value);
            if (options.includes(input.value)) {
                window.location.hash = `#element-${input.value}`;
            }
        }

        /**
         * Replaces the main content area with new content.
         * @param {DocumentFragment|HTMLElement} el - Content to display
         */
        function setMainContent(el) {
            const mainEl = document.querySelector("main");
            removeChildren(mainEl);
            mainEl.appendChild(el);
        }

        /**
         * Displays an element's full documentation in the main area.
         * Shows element definition, type information, and collapsible instance view.
         * @param {string} element - Name of the XSD element to display
         */
        function showElement(element) {
            if(!document.querySelector(
                `template[data-type="element-contents"][data-name="${element}"]`)) {
                alert(`No such element: ${element}`);
                return;
            }

            document.getElementById("root-element-name").value = element;

            const template = document.getElementById("root-element-template");
            const contentEl = template.content.cloneNode(true);

            contentEl.querySelectorAll("h2").forEach(el => {
                el.innerText = el.innerText.replace("ROOT_ELEM", element);
            });
            contentEl.querySelector("xbe-ref").setAttribute("ref", element);
            contentEl.querySelector("xbe-collapsible-element-ref")
                .setAttribute("element", element);

            setMainContent(contentEl);
        }

        /**
         * Displays a type's full documentation in the main area.
         * Shows type definition, attributes, child elements, and inheritance info.
         * @param {string} type - Name of the XSD type to display
         */
        function showType(type) {
            if(!document.querySelector(
                `template[data-type="type-contents"][data-name="${type}"]`)) {
                alert(`No such type: ${type}`);
                return;
            }

            const template = document.getElementById("root-type-template");
            const contentEl = template.content.cloneNode(true);

            contentEl.querySelectorAll("h2").forEach(el => {
                el.innerText = el.innerText.replace("ROOT_TYPE", type);
            });
            contentEl.querySelectorAll("xbe-ref").forEach(refEl => {
                refEl.setAttribute("ref", type);
            });

            setMainContent(contentEl);
        }

        /**
         * Displays a group's full documentation in the main area.
         * Shows group definition and contained elements.
         * @param {string} group - Name of the XSD group to display
         */
        function showGroup(group) {
            if(!document.querySelector(
                `template[data-type="group-contents"][data-name="${group}"]`)) {
                alert(`No such group: ${group}`);
                return;
            }

            const template = document.getElementById("root-group-template");
            const contentEl = template.content.cloneNode(true);

            contentEl.querySelectorAll("h2").forEach(el => {
                el.innerText = el.innerText.replace("ROOT_GROUP", group);
            });
            contentEl.querySelectorAll("xbe-ref").forEach(el => {
                el.setAttribute("ref", group);
            });

            setMainContent(contentEl);
        }

        /** @type {string} Current URL hash (without #) for state tracking */
        let currentHash = '';

        /** @type {boolean} Flag to prevent saving state while restoring */
        let restoringState = false;

        /**
         * Returns the localStorage key for storing details open/close state.
         * Key is unique per document (based on document.title).
         * @returns {string} Storage key in format "xbe-details-{title}"
         */
        function getDetailsStorageKey() {
            return 'xbe-details-' + document.title;
        }

        /**
         * Retrieves all saved details state from localStorage.
         * @returns {Object.<string, {openElements: string[], usagesOpen: boolean}>}
         *          Map of hash -> state object
         */
        function getAllDetailsState() {
            try {
                return JSON.parse(localStorage.getItem(getDetailsStorageKey())) || {};
            } catch(e) {
                return {};
            }
        }

        /**
         * Saves the current open/close state of all details elements for a hash.
         * Records which collapsible elements are expanded and whether the
         * "Used by" box is open.
         * @param {string} hash - URL hash to save state for
         */
        function saveDetailsStateForHash(hash) {
            if (!hash) return;
            const state = getAllDetailsState();
            const openElements = [];
            document.querySelectorAll('main details.collapsible-element-ref[open]')
                .forEach(d => {
                    if (d.dataset.element) openElements.push(d.dataset.element);
                });
            const usagesBox = document.querySelector('main details.usages-box');
            state[hash] = {
                openElements,
                usagesOpen: usagesBox ? usagesBox.open : false
            };
            try {
                localStorage.setItem(getDetailsStorageKey(), JSON.stringify(state));
            } catch(e) {}
        }

        /**
         * Saves details state for the current hash.
         * Convenience wrapper around saveDetailsStateForHash.
         */
        function saveDetailsState() {
            saveDetailsStateForHash(currentHash);
        }

        /**
         * Restores saved open/close state of details elements for current hash.
         * Opens previously expanded elements in a loop (since opening a parent
         * may reveal children that also need restoring). Sets restoringState flag
         * to prevent save-on-toggle during restoration.
         */
        function restoreDetailsState() {
            if (!currentHash) return;
            const state = getAllDetailsState();
            const hashState = state[currentHash];
            if (!hashState) return;
            restoringState = true;
            try {
                if (hashState.usagesOpen) {
                    const usagesBox = document.querySelector('main details.usages-box');
                    if (usagesBox) usagesBox.open = true;
                }
                if (hashState.openElements && hashState.openElements.length > 0) {
                    const openSet = new Set(hashState.openElements);
                    let changed = true;
                    while (changed) {
                        changed = false;
                        document.querySelectorAll(
                            'main details.collapsible-element-ref:not([open])')
                            .forEach(d => {
                                if (openSet.has(d.dataset.element)) {
                                    d.open = true;
                                    onCollapsibleElementRefToggle(d);
                                    changed = true;
                                }
                            });
                    }
                }
            } finally {
                restoringState = false;
            }
        }

        /**
         * Main navigation handler - parses URL hash and displays appropriate content.
         * Saves state for previous hash before switching, then restores state for
         * new hash after content is built. Supports hash formats:
         * - #element-{name} -> showElement()
         * - #type-{name} -> showType()
         * - #group-{name} -> showGroup()
         */
        function showFromHash() {
            if (currentHash) {
                saveDetailsStateForHash(currentHash);
            }
            const hash = window.location.hash.substring(1);
            currentHash = hash;
            if(hash.startsWith("element-")) {
                showElement(hash.substring(8));
            } else if(hash.startsWith("type-")) {
                showType(hash.substring(5));
            } else if(hash.startsWith("group-")) {
                showGroup(hash.substring(6));
            }
            restoreDetailsState();
        }

        // Initialize: handle hash on page load and hash changes
        window.addEventListener("hashchange", showFromHash);
        window.addEventListener("DOMContentLoaded", showFromHash);

        // Save details state on every toggle (capture phase to catch before bubbling)
        document.addEventListener('toggle', function(e) {
            if (restoringState) return;
            if (e.target.closest('main')) saveDetailsState();
        }, true);
    </script>

    <style>
        /* === Typography === */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            margin: 0;
            color: #1f2937;
            background-color: #fafafa;
        }

        .element-head, .element-end, .attribute, code {
            font-family: "SF Mono", "Consolas", "Monaco", "Menlo", monospace;
            font-size: 13px;
        }

        main {
            margin: 16px;
        }

        /* === Header === */
        header {
            background-color: #2c3e50;
            padding: 12px 16px;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
            border-bottom: 3px solid #1a252f;
        }
        header h1 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
            color: #fff;
        }
        header input[type="text"] {
            padding: 6px 10px;
            border: 1px solid #4a5568;
            border-radius: 4px;
            background-color: #fff;
            font-size: 13px;
        }

        h2 {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-top: 24px;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e5e7eb;
        }

        code {
            background-color: #f3f4f6;
            padding: 1px 4px;
            border-radius: 3px;
        }

        ul, ol {
            margin: 0 4px;
            padding-left: 20px;
        }

        xbe-ref {
            display: contents;
        }

        /* === Element display === */
        .element-head, .element-end {
            /* Make elements touch each other directly without regard for
               whitespace. We can then set margin/padding as necessary */
            display: flex;
            flex-direction: row;
        }

        .element-end {
            margin-bottom: 12px;
        }

        .element-head :last-child {
            /* Align closing ">" */
            align-self: end;
        }

        :is(.element-head, .element-end) .sample {
            color: #4b5563;
            font-style: italic;
        }

        .element-children, .extension-content {
            padding-left: 24px;
        }

        /* === Badges === */
        .occurs {
            display: inline-flex;
            align-self: end;
            margin-left: 8px;
            border-radius: 10px;
            padding: 1px 8px;
            font-size: 11px;
            font-weight: 500;
            background-color: #e5e7eb;
            color: #374151;
        }

        .small-note {
            display: inline;
            margin-left: 8px;
            border-radius: 10px;
            padding: 1px 8px;
            font-size: 11px;
            font-weight: 500;
            background-color: #fef3c7;
            color: #92400e;
        }

        /* === Attributes === */
        .attribute {
            display: flex;
            flex-direction: row;
            margin-left: 8px;
        }

        /* === Annotations === */
        .annotation {
            color: #6b7280;
            margin-top: 4px;
            margin-bottom: 12px;
            max-width: 800px;
            font-style: italic;
        }

        /* === Origin labels === */
        .origin {
            font-size: 11px;
            font-weight: 500;
            color: #6b7280;
            background-color: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            margin-bottom: 6px;
            display: inline-block;
        }

        /* Always-shown origins */
        .builtin-type .origin {
            display: inline-block;
        }

        :is(.extension, .simple-list, .restriction)
        > :is(.note, .builtin-type, .simple-type, .origin) {
            display: inline;
            color: #1e40af;
        }

        /* === Attribute boxes === */
        :is(.complex-type-attrs, .extension-attrs, .restriction-attrs,
            .attribute-group, .substitution-group) {
            display: block;
            margin: 6px 8px;
            padding: 8px 12px;
            border-left: 3px solid #6c757d;
            border-top: 1px solid #e5e7eb;
            border-right: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
            border-radius: 3px;
            background-color: #fff;
        }

        :is(.complex-type-attrs, .extension-attrs, .restriction-attrs,
            .attribute-group) > .note {
            font-size: 11px;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 6px;
        }

        /* === Choice and Sequence boxes === */
        .choice, .sequence {
            display: block;
            margin: 6px 8px;
            padding: 8px 12px;
            border-radius: 3px;
            background-color: #fff;
        }

        .choice {
            border-left: 4px solid #b85450;
            border-top: 1px solid #e5e7eb;
            border-right: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
        }
        .choice > .origin {
            color: #991b1b;
            background-color: #fee2e2;
        }

        .sequence {
            border-left: 4px solid #4a7c59;
            border-top: 1px solid #e5e7eb;
            border-right: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
        }
        .sequence > .origin {
            color: #166534;
            background-color: #dcfce7;
        }

        /* === Union box === */
        .simple-union {
            display: block;
            margin: 6px 8px;
            padding: 8px 12px;
            border-left: 4px solid #4a6fa5;
            border-top: 1px solid #e5e7eb;
            border-right: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
            border-radius: 3px;
            background-color: #fff;
        }
        .simple-union > .origin {
            color: #1e40af;
            background-color: #dbeafe;
        }

        .group-wrapper > .origin {
            display: inline;
        }

        /* === Links === */
        a {
            text-decoration: none;
            transition: background-color 0.15s ease;
        }
        a:hover {
            text-decoration: underline;
        }

        /* Element links */
        a[href^="#element-"] {
            color: #2563eb;
        }
        a[href^="#element-"]:hover {
            background-color: rgba(37, 99, 235, 0.1);
            border-radius: 2px;
        }

        /* Type links */
        a[href^="#type-"] {
            color: #7c3aed;
        }
        a[href^="#type-"]:hover {
            background-color: rgba(124, 58, 237, 0.1);
            border-radius: 2px;
        }

        /* Group links */
        a[href^="#group-"], a[href^="#attribute-group-"] {
            color: #059669;
        }
        a[href^="#group-"]:hover, a[href^="#attribute-group-"]:hover {
            background-color: rgba(5, 150, 105, 0.1);
            border-radius: 2px;
        }

        /* === Disclosure triangles === */
        .collapsible-element-ref > summary:first-of-type::marker {
            display: none;
        }
        .collapsible-element-ref > summary:first-of-type {
            display: flex;
            cursor: pointer;
        }
        .collapsible-element-ref > summary:first-of-type > .arrow {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
        }
        .collapsible-element-ref > summary:first-of-type > .arrow::before {
            content: "▸";
            font-size: 16px;
            color: #6b7280;
        }
        .collapsible-element-ref[open] > summary:first-of-type > .arrow::before {
            content: "▾";
        }
        .collapsible-element-ref > summary:first-of-type:hover > .arrow::before {
            color: #374151;
        }
        .collapsible-element-ref[open] > summary > .simple {
            display: none;
        }
        .collapsible-element-ref > summary > .detailed {
            display: none;
        }
        .collapsible-element-ref[open] > summary > .detailed {
            display: initial;
        }

        /* === Usages box === */
        .usages-box {
            margin-bottom: 12px;
        }

        .usages-box > summary::marker {
            display: none;
        }
        .usages-box > summary {
            display: flex;
            margin-bottom: 6px;
            cursor: pointer;
            font-size: 13px;
            color: #4b5563;
        }
        .usages-box > summary:hover {
            color: #1f2937;
        }
        .usages-box > summary::before {
            content: "▸";
            font-size: 16px;
            width: 18px;
            color: #6b7280;
        }
        .usages-box[open] > summary::before {
            content: "▾";
        }

        .usages-box .usages {
            margin-left: 16px;
        }

        .usages a {
            font-size: 12px;
        }
    </style>
</head>
<body>
    {% macro el_template(type, el) %}
        <template data-type="{{ type }}"
                  {{ el|elem_path_attrs|xmlattr }}>
            {{ caller() }}
        </template>
    {% endmacro %}

    {% macro el_div(class, el) %}
        <div class="{{ class }}"
             {{ el|elem_name_attrs|xmlattr }}>
            {{ caller() }}
        </div>
    {% endmacro %}

    {% macro elem_link(name, on) %}
        {{ record_usage(on, ("element", name)) }}
        <a class="element-link"
           href="#element-{{ name }}">
            {{ name }}
        </a>
    {% endmacro %}

    {% macro type_link(type, on) %}
        {{ record_usage(on, ("type", type)) }}
        {% if not type.startswith("xsd:") %}
            <a class="type-link"
               href="#type-{{ type }}">
                {{ type }}
            </a>
        {% else %}
            <span>{{ type }}</span>
        {% endif %}
    {% endmacro %}

    {% macro group_link(name, on) %}
        {{ record_usage(on, ("group", name)) }}
        <a class="group-link"
           href="#group-{{ name }}">
            {{ name }}
        </a>
    {% endmacro %}

    {% macro attribute(attr_el, on) %}
        <span class=attribute
              {{ attr_el|elem_name_attrs|xmlattr }}>
            {{ attr_el.attrib.name }}=
            {% if attr_el.attrib.type %}
                {{ type_link(attr_el.attrib.type, on) }}
            {% else %}
                {% for st_el in attr_el|xpath("xsd:simpleType") %}
                    {{ simple_type_contents(st_el) }}
                {% endfor %}
            {% endif %}
            {% set occurs = attr_el.attrib.use|default("optional") %}
            {% if occurs != "optional" %}
                <span class=occurs>{{ occurs }}</span>
            {% endif %}
        </span>
    {% endmacro %}

    {% macro child_attributes(el, on) %}
        {% for attr_el in el|xpath("xsd:attribute") %}
            {{ attribute(attr_el, on) }}
        {% endfor %}
        {% for attrgr_el in el|xpath("xsd:attributeGroup[@ref]") %}
            {{ record_usage(on, ("attribute-group", attrgr_el.attrib.ref)) }}
            <xbe-ref type=attribute-group ref="{{ attrgr_el.attrib.ref }}"></xbe-ref>
        {% endfor %}
    {% endmacro %}

    {% macro child_elements(el, on) %}
        {% for elem_el in el|xpath("xsd:element") %}
            {% set ref = elem_el.attrib.name or elem_el.attrib.ref %}
            {{ record_usage(on, ("element", ref)) }}
            <xbe-collapsible-element-ref element="{{ ref }}">
                <span slot=after-head>
                    {{ element_occurs(elem_el) }}
                </span>
            </xbe-collapsible-element-ref>
        {% endfor %}

        {% for choice_el in el|xpath("xsd:choice") %}
            {% call el_div("choice", choice_el) %}
                <span class="origin">Choice</span>
                {{ element_occurs(choice_el) }}
                {{ child_annotations(choice_el) }}
                {{ child_elements(choice_el, on) }}
            {% endcall %}
        {% endfor %}

        {% for seq_el in el|xpath("xsd:sequence") %}
            {% call el_div("sequence", seq_el) %}
                <span class="origin">Sequence</span>
                {{ element_occurs(seq_el) }}
                {{ child_annotations(seq_el) }}
                {{ child_elements(seq_el, on) }}
            {% endcall %}
        {% endfor %}

        {% for group_el in el|xpath("xsd:group") %}
            <div class=group-wrapper>
                {{ elem_origin("group", group_el) }}
                {{ element_occurs(group_el) }}
                {% if "ref" in group_el.attrib %}
                    {{ group_contents_ref(group_el.attrib.ref, on) }}
                {% else %}
                    {{ group_contents(group_el, on) }}
                {% endif %}
            </div>
        {% endfor %}
    {% endmacro %}

    {% macro child_annotations(el) %}
        {% for doc_el in el|xpath("xsd:annotation/*") %}
            <p class=annotation>{{ doc_el|xpath("string()") }}</p>
        {% endfor %}
    {% endmacro %}

    {% macro elem_origin(prefix, el, kind="") %}
        <div class=origin>
            {% if "name" in el.attrib or "ref" in el.attrib %}
                {{ prefix|capitalize }}
                {% if kind == "type" %}
                    {{ type_link(el.attrib.name or el.attrib.ref) }}
                {% else %}
                    {{ el.attrib.name or el.attrib.ref }}
                {% endif %}
            {% else %}
                Inline {{ prefix }}
            {% endif %}
        </div>
    {% endmacro %}

    {% macro complex_type_origin(ct_el) %}
        {{ elem_origin("complex type", ct_el, kind="type") }}
    {% endmacro %}

    {% macro complex_type_attrs(ct_el, on) %}
        <span class=complex-type-attrs {{ ct_el|elem_name_attrs|xmlattr }}>
            {{ complex_type_origin(ct_el) }}
            {{ child_attributes(ct_el, on) }}

            {% for ext_el in ct_el|xpath("(xsd:simpleContent|xsd:complexContent)/xsd:extension") %}
                {% call el_div("extension-attrs", ext_el) %}
                    <div class=note>Inherited attributes from {{ ext_el.attrib.base }}:</div>
                    <div class="inherited">
                        {{ type_attrs_ref(ext_el.attrib.base, on) }}
                    </div>

                    <div class=note>New attributes:</div>
                    {{ child_attributes(ext_el, on) }}
                {% endcall %}
            {% endfor %}

            {% for rest_el in ct_el|xpath("(xsd:simpleContent|xsd:complexContent)/xsd:restriction") %}
                {% call el_div("restriction-attrs", rest_el) %}
                    <div class=note>Inherited attributes from {{ rest_el.attrib.base }}:</div>
                    <div class="inherited">
                        {{ type_attrs_ref(rest_el.attrib.base, on) }}
                    </div>

                    <div class=note>Allowed attributes:</div>
                    {{ child_attributes(rest_el, on) }}
                {% endcall %}
            {% endfor %}
        </span>
    {% endmacro %}
    
    {% macro inherited_elements(base, on) %}
        {% for base_ct in doc|xpath('//xsd:complexType[@name="{}"]'.format(base)) %}
            {{ child_elements(base_ct, on) }}
        {% endfor %}
    {% endmacro %}

    {% macro extended_by(type_name) %}
        {% set local = type_name.split(":")[-1] %}
        {% set derived = doc|xpath(
            '//xsd:complexType[(xsd:simpleContent|xsd:complexContent)/xsd:extension[' ~
            'substring-after(@base, ":")="{}" or @base="{}"]]'.format(local, type_name)
        ) %}
        {% set derived = derived|rejectattr("attrib.name", "equalto", type_name)|list %}

        {% if derived %}
            <div class="usages-box">
                <summary><strong>Extended by:</strong></summary>
                <ul class="usages">
                    {% for ct in derived %}
                        <li><a href="#type-{{ ct.attrib.name }}">{{ ct.attrib.name }}</a></li>
                    {% endfor %}
                </ul>
            </div>
        {% endif %}
    {% endmacro %}

    {% macro complex_type_contents(ct_el, on) %}
        {% call el_div("complex-type-contents", ct_el) %}
            {{ complex_type_origin(ct_el) }}
            {% if ct_el.attrib.name %}{{ extended_by(ct_el.attrib.name) }}{% endif %}
            {{ child_annotations(ct_el) }}

            {# 1) Vlastní elementy typu #}
            {{ child_elements(ct_el, on) }}

            {# 2) Zděděné elementy #}
            {% for ext_el in ct_el|xpath("(xsd:simpleContent|xsd:complexContent)/xsd:extension") %}
                {% call el_div("extension", ext_el) %}
                    <div class=note>Inherited from {{ ext_el.attrib.base }}:</div>
                    <div class="extension-content inherited">
                        {{ inherited_elements(ext_el.attrib.base, on) }}
                    </div>

                    <div class=note>New elements:</div>
                    {{ child_elements(ext_el, on) }}
                {% endcall %}
            {% endfor %}

            {# 3) Restriction #}
            {% for rest_el in ct_el|xpath("(xsd:simpleContent|xsd:complexContent)/xsd:restriction") %}
                {% call el_div("restriction", rest_el) %}
                    <div class=note>Inherited from {{ rest_el.attrib.base }}:</div>
                    <div class="restriction-content inherited">
                        {{ inherited_elements(rest_el.attrib.base, on) }}
                    </div>

                    <div class=note>Allowed elements:</div>
                    {{ child_elements(rest_el, on) }}
                {% endcall %}
            {% endfor %}
        {% endcall %}
    {% endmacro %}

    {% macro simple_type_contents(st_el, on) %}
        {% call el_div("simple-type", st_el) %}
            {{ elem_origin("simple type", st_el) }}
            {{ child_annotations(st_el) }}

            {% for union_el in st_el|xpath("xsd:union") %}
                {% call el_div("simple-union", union_el) %}
                    <span class="origin">Union</span>
                    {% for st2_name in (union_el.attrib.memberTypes|default("")).split() %}
                        {{ type_contents_ref(st2_name, on) }}
                    {% endfor %}
                    {% for st2_el in union_el|xpath("xsd:simpleType") %}
                        {{ simple_type_contents(st2_el, on) }}
                    {% endfor %}
                {% endcall %}
            {% endfor %}

            {% for list_el in st_el|xpath("xsd:list") %}
                {% call el_div("simple-list", list_el) %}
                    List of:
                    {{ type_contents_ref(list_el.attrib.itemType, on) }}
                {% endcall %}
            {% endfor %}

            {% for rest_el in st_el|xpath("xsd:restriction") %}
                {% call el_div("restriction", rest_el) %}
                    Restriction of:
                    {{ type_contents_ref(rest_el.attrib.base, on) }}

                    <ul>
                        {% for el in rest_el %}
                            <li><code>{{ el|prettyprint_xml }}</code></li>
                        {% endfor %}
                    </ul>
                {% endcall %}
            {% endfor %}
        {% endcall %}
    {% endmacro %}

    {% macro group_contents(group_el, on) %}
        {% call el_div("group-contents", group_el) %}
            {{ child_annotations(group_el) }}
            {{ child_elements(group_el, on) }}
        {% endcall %}
    {% endmacro %}

    {% macro usages_content_inner(type, name) %}
        {% for from_t, from_n in usages_by_name[(type, name)] %}
            {% if from_t == "element" %}
                <li>{{ elem_link(from_n) }}</li>
            {% elif from_t == "type" %}
                <li>{{ type_link(from_n) }}</li>
            {% elif from_t == "group" %}
                <li>{{ group_link(from_n) }}</li>
            {% else %}
                <li>{{ from_t }} {{from_n}}</li>
            {% endif %}
        {% endfor %}
    {% endmacro %}

    {% macro usages_content_sg(el, type) %}
        {% if el.attrib.substitutionGroup %}
            <li class=subst-usages>
                <span class=origin>Substitution group {{ el.attrib.substitutionGroup }}</span>
                <ul>
                    {{ usages_content_inner(type, el.attrib.substitutionGroup) }}

                    {% if type == "element" %} {# TODO: Other types #}
                        {% for base_el in doc|xpath('//xsd:element[@name="{}"]'.format(
                                el.attrib.substitutionGroup)) %}
                                {{ usages_content_sg(base_el, type) }}
                        {% endfor %}
                    {% endif %}
                </ul>
            </li>
        {% endif %}
    {% endmacro %}

    {% macro usages_content(named_el) %}
        {% set type = named_el|elem_type %} 
        <ul class=usages>
            {{ usages_content_inner(type, named_el.attrib.name) }}
            {{ usages_content_sg(named_el, type) }}
        </ul>
    {% endmacro %}

    {% macro type_attrs_ref(type, on) %}
        {% if not type %}
        {% elif not type.startswith("xsd:") %}
            {{ record_usage(on, ("type", type)) }}
            {# Builtin types don't have attributes(?) #}
            <xbe-ref type=type-attrs ref="{{ type }}"></xbe-ref>
        {% endif %}
    {% endmacro %}

    {% macro type_contents_ref(type, on) %}
        {% if not type %}
        {% elif not type.startswith("xsd:") %}
            {{ record_usage(on, ("type", type)) }}
            <xbe-ref type=type-contents ref="{{ type }}"></xbe-ref>
        {% else %}
            <div class=builtin-type>
                <div class=origin>Builtin type {{ type }}</div>
            </div>
        {% endif %}
    {% endmacro %}

    {% macro record_usage(on, uses) %}
        {% if on %}
            {% do usages_by_name[uses].add(on) %}
        {% endif %}
    {% endmacro %}

    {% macro element_occurs(el) %}
        {% set min_occurs = el.attrib.minOccurs|default("1") %}
        {% set max_occurs = el.attrib.maxOccurs|default("1") %}
        {% if max_occurs == "unbounded" %}
            {% set max_occurs = "*" %}
        {% endif %}
        {% if min_occurs != "1" or max_occurs != "1" %}
            <span class=occurs>
                <span>{{ el.attrib.minOccurs|default(1) }}</span>
                <span class=sep>:</span>
                <span>{{ max_occurs }}</span>
            </span>
        {% endif %}
    {% endmacro %}

    {% macro group_contents_ref(name, on) %}
        {{ record_usage(on, ("group", name)) }}
        <xbe-ref type=group-contents ref="{{ name }}"></xbe-ref>
    {% endmacro %}

    <div id=elements>
        {% for elem_el in doc|xpath("//xsd:element[@name]") %}
            {% set on = ("element", elem_el.attrib.name) %}
            {% call el_template("element-head", elem_el) %}
                {% call el_div("element-head", elem_el) %}
                    &lt;{{ elem_el.attrib.name }}
                    {% if elem_el.attrib.abstract == "true" %}
                        <span class=small-note>abstract</span>
                    {% endif %}
                    {{ child_attributes(elem_el, on) }}
                    {% for ct_el in elem_el|xpath("xsd:complexType") %}
                        {{ complex_type_attrs(ct_el, on) }}
                    {% else %}
                        {{ type_attrs_ref(elem_el.attrib.type, on) }}
                    {% endfor %}
                    <span>&gt;</span>
                {% endcall %}
            {% endcall %}

            {% call el_template("element-contents", elem_el) %}
                {% call el_div("element-children", elem_el) %}
                    {{ child_annotations(elem_el) }}

                    {% for ct_el in elem_el|xpath("xsd:complexType") %}
                        {{ complex_type_contents(ct_el, on) }}
                    {% else %}
                        {{ type_contents_ref(elem_el.attrib.type, on) }}
                    {% endfor %}
                {% endcall %}
            {% endcall %}
        {% endfor %}
    </div>

    <div id=attribute-groups>
        {% for attrgr_el in doc|xpath("//xsd:attributeGroup[@name]") %}
            {% set on = ("attribute-group", attrgr_el.attrib.name) %}
            {% call el_template("attribute-group", attrgr_el) %}
                {% call el_div("attribute-group", attrgr_el) %}
                    {{ elem_origin("attribute group", attrgr_el) }}
                    {{ child_annotations(attrgr_el) }}
                    {% for attr_el in attrgr_el|xpath("xsd:attribute") %}
                        {{ attribute(attr_el, on) }}
                    {% endfor %}
                {% endcall %}
            {% endcall %}
        {% endfor %}
    </div>

    <div id=complex-types>
        {% for ct_el in doc|xpath("//xsd:complexType[@name]") %}
            {% set on = ("type", ct_el.attrib.name) %}
            {% call el_template("type-attrs", ct_el) %}
                {{ complex_type_attrs(ct_el, on) }}
            {% endcall %}

            {% call el_template("type-contents", ct_el) %}
                {{ complex_type_contents(ct_el, on) }}
            {% endcall %}
        {% endfor %}
    </div>

    <div id=simple-types>
        {% for st_el in doc|xpath("//xsd:simpleType[@name]") %}
            {% set on = ("type", st_el.attrib.name) %}
            {% call el_template("type-attrs", st_el) %}
            {% endcall %}

            {% call el_template("type-contents", st_el) %}
                {{ simple_type_contents(st_el, on) }}
            {% endcall %}
        {% endfor %}
    </div>

    <div id=groups>
        {% for group_el in doc|xpath("//xsd:group[@name]") %}
            {% set on = ("group", group_el.attrib.name) %}
            {% call el_template("group-contents", group_el) %}
                {{ group_contents(group_el, on) }}
            {% endcall %}
        {% endfor %}
    </div>

    <div id=usages>
        {% for named_el in doc|xpath(
                "(//xsd:element|//xsd:simpleType|//xsd:complexType|//xsd:group|//xsd:attributeGroup)[@name]") %}
            {% set type = named_el|elem_type %}
            {% call el_template(type + "-usages", named_el) %}
                {{ usages_content(named_el) }}
            {% endcall %}
        {% endfor %}
    </div>

    <template id=collapsible-element-ref-template>
        <details class=collapsible-element-ref
                 data-element=ELEMENT
                 ontoggle="onCollapsibleElementRefToggle(this)">
            <summary>
                <div class=arrow></div>
                <span class=simple>&lt;ELEMENT&gt;...&lt;/ELEMENT&gt;</span>
                <xbe-ref class=detailed type=element-head ref="ELEMENT"></xbe-ref>
                <slot name=after-head></slot>
            </summary>

            <div class=element-contents></div>
            <div class=element-end>
                &lt;/ELEMENT&gt;
            </div>
        </details>
    </template>

    <template id=root-element-template>
        <div class=standalone-element>
            <h2>Type ROOT_ELEM</h2>
            <details class=usages-box>
                <summary>Used by:</summary>
                <xbe-ref type=element-usages ref=ROOT_ELEM></xbe-ref>
            </details>
            <xbe-collapsible-element-ref element="ELEMENT">
            </xbe-collapsible-element-ref>
        </div>
    </template>

    <template id=root-type-template>
        <div class=standalone-type>
            <h2>Type ROOT_TYPE</h2>
            <details class=usages-box>
                <summary>Used by:</summary>
                <xbe-ref type=type-usages ref=ROOT_TYPE></xbe-ref>
            </details>
            <div class=element-head>
                &lt;
                <span class=sample>element</span>
                <xbe-ref type=type-attrs ref=ROOT_TYPE></xbe-ref>
                <span>&gt;</span>
            </div>
            <xbe-ref type=type-contents ref=ROOT_TYPE></xbe-ref>
            <div class=element-end>
                &lt;/<span class=sample>element</span>&gt;
            </div>
        </div>
    </template>

    <template id=root-group-template>
        <div class=standalone-group>
            <h2>Group ROOT_GROUP</h2>
            <details class=usages-box>
                <summary>Used by:</summary>
                <xbe-ref type=group-usages ref=ROOT_GROUP></xbe-ref>
            </details>
            <xbe-ref type=group-contents ref=ROOT_GROUP></xbe-ref>
        </div>
    </template>

    <header>
        <h1>{{ main_xml_path.name }}</h1>

        <form onsubmit="onElementFormSubmit()">
            <label for=root-element-name
                   title="Global elements that can serve as XML document roots. Local elements nested in types are not listed."
                   >Root element:</label>
            <input type=text
                   list=element-list
                   id=root-element-name
                   placeholder="Element name"
                   oninput="onElementInputChange()">
            <datalist id=element-list>
                {% for elem_el in doc|xpath("xsd:element[@name]") %}
                    <option>{{ elem_el.attrib.name }}</option>
                {% endfor %}
            </datalist>
            <button>
                Show element
            </button>
        </form>
    </header>

    <main>
    </main>
</body>
</html>
